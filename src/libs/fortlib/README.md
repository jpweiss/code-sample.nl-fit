C++ Facades for BLAS and LMDER
==============================

 

You are likely reading this file because the other README files have
directed you here, as a prerequisite to examining the `FitLM_Adapter`
class.  This file should provide a good overview of reason why
`FitLM_Adapter` exists.  Its source-code documentation (generated by
Doxygen) provides the technical details for how to use it.  The latter
should make more sense, however, after reading this file.


**WARNING**:

This library is **not** **reentrant!!!**  It cross-links to FORTRAN
libraries whose thread-safety is completely unknown.


---


This directory contains C++ code that acts as a Facade to parts of the
BLAS and LMDER libraries.


All of the `*.f` files here come from those two libraries **and are
NOT MY code!**


> BLAS and LMDER are two FORTRAN libraries widely-used by the
> scientific community (hence why they're written in FORTRAN).
> Only the parts of BLAS and LMDER that I required for my research are
> here.  The actual libraries are far more extensive.


There are other files here, used by another library in this code
sample.  They're stock sorting routines from BLAS, and I intend to
replace them at a later date with a sorting algorithm from the C++
STL.

The files that you want to look at are:

* `FitLM.h`
* `FitLM_Adapter.h`
* `FORTTypes.h`
* `FitLM.c`


To see `FitLM_Adapter` in action, start by reading
`src/lib/measure/README.md`, then look at the classes in the `measure`
library.


---


### `FitLM`:  Motivation for `FitLM_Adapter` ###


`FitLM_Adapter` is, as the name implies, an application of the Adapter
pattern to the class `FitLM`.

`FitLM` is a lightweight functor-style wrapper-class around calls to
the FORTRAN library, LMDER, which performs nonlinear least-squares
fitting.  Not only must `FitLM` handle the “impedance-mismatch”
between C/C++ and FORTRAN, it tries to whittle away at the complexity
of the LMDER library.  The main function in LMDER takes **24**
arguments and returns a status code with 8 possible values.  Moreover,
the first of those 24 arguments is an 8-argument C-function-pointer
that is actually used in LMDER as a FORTRAN function.  `FitLM` reduces
this mess down to 8 arguments (spread between the constructor and the
functor call) and converts the return status to an enum with
self-explanatory tag names.

`FitLM` has Doxygen-generated source-code documentation containing a
more mathematical explanation of its use.

However, `FitLM` still has some unsatisfying requirements:

* It still requires a C function-pointer ... not a C++
  function-pointer ... that will be called from a FORTRAN library.

* All data passed to and from LMDER must be in the form of pointers.
  + Passing pointers all over the place gives C++ programmers the
    willies (or should).
  + However, copying the data from these pointers to C arrays to C++
    data structures, and vice-versa, would be a performance hit.

* LMDER is much more general-purpose.  To use it to fit a nonlinear
  function to a dataset, one needs to combine the dataset with the
  function you're fitting it to.

  This is a “conceptual impedance-mismatch”, and an unnecessary one,
  at that.


It would be far nicer, and more in line with C++ programming, if we
had a class that did the following:

* Takes a C++ functor that computes the function being fit, and does
  **nothing** else.

* Takes a C++ data structure containing the dataset to fit ...
  **separate** from the function being fit to it and from any other
  dataset.

* Avoids copying the dataset between the C++ object and a C-array.


### `FitLM_Adapter` ###


`FitLM_Adapter`, a template class that inherits `FitLM`, separates the
the dataset from the model that it's being fit to.  The two template
parameters specify the data-container's type, and a functor-class that
implements the model.  Both the data and the model's "fit-functor" are
passed to an overloaded `FitLM_Adapter::operator()()`.

It accomplishes the separation of fit-functor and data by using a
static member "wrapper-function" that calls the fit-functor, passing
it the data along with the other arguments.  Sadly, there's no good
way around this.  The wrapper-function is ultimately passed to the
FORTRAN function, `lmder_`, which dictates the call-signature.
Naturally, this prevents `FitLM_Adapter` itself from being re-entrant.
(Well, partially prevents it.  See the source-code documentation of
the `FitLM_Adapter::fit_function_adapter` member for the details of
the actual limits on re-entrancy.)  At present, I have no need to make
this thread-safe, so I've chosen to live with these limitations.

Also, the wrapper-function still passes pointer-based arrays to the
fit-functor.  This, again, is a limitation inherited from the external
call from the FORTRAN function, `lmder_`.  I have plans to eventually
create and use adapter-classes to present a more STL-like container to
the fit-functor, thereby eliminating both the pointer-based arrays and
the integer size-arguments, all without copying data.  That will be
coming at a later date.


When you examine the source-documentation for `FitLM_Adapter`, you'll
notice that the constructor still requires an argument specifying the
size of the (potential) dataset.  This is intentional.  `FitLM`, must
allocates several internal buffers required by the FORTRAN `lmder_`
algorithm.  My research code is repeatedly fitting different datasets,
all with the same size, from within a loop.  Clearly, moving all
internal allocations into the constructor is the way to go.  Memory
allocation & deallocation in every `FitLM::operator()()`-call would
obviously incur a large performance-hit.


---


### Next:  `FitLM_BarrierAdapter` and the `measure`-Library ###


The next thing you'll want to read is `src/lib/measure/README.md`.
The `measure`-library uses the `FitLM_Adapter` with a model.

It's not only a good example of how one uses `FitLM_Adapter`, but also
of using policy-classes to tweak a model at compile-time.
