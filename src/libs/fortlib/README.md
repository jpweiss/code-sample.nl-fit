C++ Facades for BLAS and LMDER
==============================

 

You are likely reading this file because the other README files have
directed you here, as a prerequisite to examining the `FitLM_Adapter`
class.  This file should provide a good overview of reason why
`FitLM_Adapter` exists.  Its source-code documentation (generated by
Doxygen) provides the technical details for how to use it.  The latter
should make more sense, however, after reading this file.


**WARNING**:

This library is **not** **reentrant!!!**  It cross-links to FORTRAN
libraries whose thread-safety is completely unknown.


---


This directory contains C++ code that acts as a Facade to parts of the
BLAS and LMDER libraries.


All of the `*.f` files here come from those two libraries **and are
NOT MY code!**


> BLAS and LMDER are two FORTRAN libraries widely-used by the
> scientific community (hence why they're written in FORTRAN).
> Only the parts of BLAS and LMDER that I required for my research are
> here.  The actual libraries are far more extensive.


There are other files here, used by another library in this code
sample.  They're stock sorting routines from BLAS, and I intend to
replace them at a later date with a sorting algorithm from the C++
STL.

The files that you want to look at are:

* `FitLM.h`
* `FitLM_Adapter.h`
* `FORTTypes.h`
* `FitLM.c`


To see `FitLM_Adapter` in action, start by reading
`src/lib/measure/README.md`, then look at the classes in the `measure`
library.


---


### `FitLM`:  Motivation for `FitLM_Adapter` ###


`FitLM_Adapter` is, as the name implies, an application of the Adapter
pattern to the class `FitLM`.

`FitLM` is a lightweight functor-style wrapper-class around calls to
the FORTRAN library, LMDER, which performs nonlinear least-squares
fitting.  Not only must `FitLM` handle the “impedance-mismatch”
between C/C++ and FORTRAN, it tries to whittle away at the complexity
of the LMDER library.  The main function in LMDER takes **24**
arguments and returns a status code with 8 possible values.  Moreover,
the first of those 24 arguments is an 8-argument C-function-pointer
that is actually used in LMDER as a FORTRAN function.  `FitLM` reduces
this mess down to 8 arguments (spread between the constructor and the
functor call) and converts the return status to an enum with
self-explanatory tag names.

`FitLM` has Doxygen-generated source-code documentation containing a
more mathematical explanation of its use.

However, `FitLM` still has some unsatisfying requirements:

* It still requires a C function-pointer ... not a C++
  function-pointer ... that will be called from a FORTRAN library.

* All data passed to and from LMDER must be in the form of pointers.
  + Passing pointers all over the place gives C++ programmers the
    willies (or should).
  + However, copying the data from these pointers to C arrays to C++
    data structures, and vice-versa, would be a performance hit.

* LMDER is much more general-purpose.  To use it to fit a nonlinear
  function to a dataset, one needs to combine the dataset with the
  function you're fitting it to.

  This is a “conceptual impedance-mismatch”, and an unnecessary one,
  at that.


It would be far nicer, and more in line with C++ programming, if we
had a class that did the following:

* Takes a C++ functor that computes the function being fit, and does
  **nothing** else.

* Takes a C++ data structure containing the dataset to fit ...
  **separate** from the function being fit to it and from any other
  dataset.

* Avoids copying the dataset between the C++ object and a C-array.


### `FitLM_Adapter` ###


`FitLM_Adapter` is a template class that inherits `FitLM`.  It has two
template parameters:  one for a functor-class, and another for a
data-container.  Through its `operator()`, the functor-type provides
the model to fit the data to.  Both the data and the model's
"fit-functor" are passed to the overloaded `FitLM_Adapter::operator()`.


(Notes:

 This Adapter's main purpose is to separate the model and the dataset.

 It does not completely eliminate pointer-based arrays, due to the
 constraints imposed by the external call to the FORTRAN fn.,
 `lmder_`.


 The 'ndata' is in the c'tor so that we can pre-allocate a bunch of
 internal arrays.

 This class cannot be made re-entrant, as it uses a static member
 fn. as a wrapper for the Functor.  I'm not interested in changing
 this at the moment.

 The wrapper calls the functor object, passing the data in.

 I have additional ideas [noted in the FIXME comments.
)


Placeholder file.  More to come...


---

